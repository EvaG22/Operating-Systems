Μπορείτε να τρέξετε το πρόγραμμα χρησιμοποιώντας την εντολή make run_sort.

Ο κώδικας για την ρίζα την ιεραρχίας βρίσκεται στο αρχείο coordinator.c, 
για τους ενδιάμεσους κόμβους στο mergers.c και για τους κόμβους φύλλα στο sorters.c
Τα δύο προγράμματα ταξινόμησης βρίσκονται στα quicksort.c και bubblesort.c αντίστοιχα.
Στο mfunctions.c βρίσκονται κάποιες βοηθητικές συναρτήσεις που χρησιμοποιούνται από τον
coordinator, οπως η handleOptions η οποία κάνει parsing τα command line arguments.
Στο record.c ορίζεται η δομη του record και μετά υπάρχουν όλες οι συναρτήσεις που τα αφορούν,
πρώτα κάποιες συναρτήσεις που χρησιμοποιούνται απο τα προγράμματα ταξινόμησηςκαι στη συνέχεια 
οι συναρτήσεις για το merging ταξινομημένων δομών, οι οποίεςχρησιμοποιούνται και στο βήμα 
των ενδιάμεσων κόμβων, και από τη ρίζα.

Για τον διαχωρισμό των γραμμών του αρχείου, αρχικά κάνω την ακέραια διαίρεση με τον αριθμό των 
ενδιάμεσων κόμων, και πριν καλέσω την exec, αναθέτω τις πιθανες εξτρα γραμμες στον πρώτο ενδιάμεσο,
εφόσον αυτός θα έχει περισσότερα παιδιά, και συνεπώς θα χειριστεί χρονικά καλύτερα έναν μεγαλυτερο
αριθμό γραμμών προς ταξινόμηση. Πιθανές εξτρα γραμμες υπάρχουν και στο βημα του διαχωρισμου των γραμμων
προς ταξινόμηση απο τον splitter στον sorter, όπου αντίστοιχα τις αναθέτω στον πρώτο κόμβο φύλλο.

sorting methods
Έχω υλοποιήσει quicksort και bubblesort, οι οποίες πέρα από το βήμα της ταξινομησης, λειτουργούν
με τον ίδιο τρόπο. Συγκεκριμένα, ανοιγουν το αρχειο και πηγαινουν τον file pointer στο σημείο που 
έχει ανατεθεί στον καθένα. Αυτό υπολογίζεται όσο κατεβαίνουμε στα επιπεδα ιεραρχίας, αλλά ουσιαστικα
ειναι το άθροισμα του αριθμου του ενδιαμεσος κόμβου στον οποίο βρισκόμαστε * τις γραμμες που αναλαμβάνει
ο καθένας, με τον αριθμό του κόμβου φύλλου στον οποίο βρισκόμαστε * τις γραμμές που έχει να ταξινομησει
το καθένα. Αφού λοιπον διαβασει τον αριθμό records που αναλογεί και το ταξινομησει, γράφει το αποτέλεσμα
στον fifoo.

Για το βήμα του merging, τόσο στους mergers όσο και στον coordinator ακολουθω την ιδια λογικη. 
Δημιουργώ πινακα με το ονομα mergedRecords για αποθηκευση τελικων αποτελεσματων και μετα διαβαζω 
τους πινακες που δημιουργουν οι κομβοι της χαμηλοτερης ιεραρχιας και καλειται η συναρτηση merge για 
τον mergedRecords και εναν απο τους πινακες (αυτον που διαβαστηκε καθε φορα). Στη συναρτηση αυτη, 
αν ο mergedRecords είναι αδειος, δηλαδη ειναι ο πρωτος πινακας που διαβαζεται, τοτε τον προσθετει ολοκληρο.
Διαφορετικα, συγκρινει τα πρωτα στοιχεια του καθε πινακα και τοποθετει το μικροτερο μεχρι να αδειασει καποιο,
οπου στη συνεχεια θα προσθεσει ολοκληρο αυτο που δεν ειναι ακομα αδειο.

Για την επικοινωνία μεταξύ των κόμβων, χρησιμοποιώ named (fifo) pipes. Συγκεκριμένα ο coordinator
δημιουργει numOfChildren pipes ονοματι fifo, έναν δηλαδή για κάθε merger και οι mergers δημιουργουν ο
καθένας τόσα pipes όσα και τα παιδιά τους. Οι pipes αυτοι λεγονται fifoo. 
Στους fifoo γραφουν οι quicksort και bubblesort μολις σχηματισουν τον ταξινομημενο πινακα και στη συνεχεια
γραφουν εκει και οι sorters τον χρονο που χρειαστηκαν για να ολοκληρωσουν την λειτουργια τους.
Τους fifoo pipes τους ανοιγουν οι mergers και διαβαζουν αρχικα το sorted array προκειμενου να το κανουν 
merge όπως περιγράφεται παραπάνω, και στη συνεχεια διαβαζουν και τον χρονο των sorters. Στην συνέχεια ανοίγουν 
τον fifo που αντιστοιχει και γραφουν εκει το merged array και τον πινακα με τον χρονο. 
Τον fifo pipe τον ανοιγει ο coordinator στο τελος, κανει merge και εκτυπωνει τον χρονο.

Υπάρχουν και αρκετά σχόλια μέσα στον κώδικα, ευελπιστώ να είναι κατανοητός. 
Σχετικα με οσα πραγματα εξηγω παραπανω, ειναι κυριως το πως θα επρεπε να δουλευει με βαση την υλοποιηση που στο
μυαλο μου έχω κανει, αλλα οπως θα διαπιστωσετε δεν γινεται. Αν κοιτάξετε τον κώδικα και κατανοησετε γιατί δεν 
λειτουργούν κάποια πραγματα, με χαρα θα ακουσω οποιαδηποτε παρατηρηση στην προφορικη εξεταση, 
γιατι παρα του αποτελεσματος, μου αρεσε σαν εργασια και θα ηθελα πολυ αυτο που παρουσιαζω να ειναι πιο αξιοπρεπες.
Καλη συνέχεια.
