Καλησπέρα, μπορείται να τρέξετε το πρόγραμμα χρησιμοποιώντας την εντολή make run 
Τα ορίσματα που χρειάζονται ειναι ένα όνομα αρχείου, ένας αριθμός απο readers και ένας αριθμός από writers.
Προκειμενου να αλλαξετε τα ορίσματα, μπορειτε να τροποποιησετε τη σειρα ARGSV = testdata/accounts5000.bin 10 10 του makefile.

Η υλοποίηση που έχω επιλέξει είναι με threads, ένα για τους readers και ένα για τους writers. Τα threads δημιουργούνται στην main.
Λόγω αυτής μου της επιλογής δεν χρησιμοποιώ τα:
./reader -f filename -l recid[,recid] -d time -s shmid και 
./write -f filename -l recid -v value -d time -s shmid
καθώς αρχικοποιώ με for loops έναν αριθμό απο readers και έναν από writers, και τα ορίσματα αυτά πρέπει να είναι
διαφορετικα για κάθε reader και για κάθε writer. Τα δοκίμασα σε πειραματικό στάδιο μόνο, όταν ακόμα έτρεχα έναν reader
και έναν writer τη φορά, ωστόσο έτσι δε μπορούσα να επιβεβαιώνω οτι επιτυγχάνεται ο σωστός συγχρονισμός. Παρακάτω θα
εξηγήσω πώς δημιουργώ τυχαιοκρατικά τις τιμές αυτές.

Τώρα σχετικά με τα αρχεία μου:
Στο sharedmem.c βρισκεται η main, το reader thread και το writer thread.
Στο procedures.c βρισκονται ολες οι βοηθητικες συναρτησεις που χρησιμοποιει η main και στο procedures.h οι δηλωσεις
αυτών καθώς και όλων των δομών και της shared memory που χρησιμοποιω στην υλοποιηση μου.
Στο read_write_proc.c βρισκονται ολες οι βοηθητικες συναρτησεις που χρησιμοποοιουν τα δυο threads και στο read_write_proc.headers
οι δηλωσεις αυτών

Οι semaphores που χρησιμοποιω ειναι οι εξης 3:
---turnstile semaphore:
Το turnstile semaphore χρησιμοποιείται για τον έλεγχο της πρόσβασης στο critical section 
τόσο για τους readers όσο και για τους writers. Εξασφαλίζει ότι οι readers και οι writers περιμένουν στη σειρά, 
με τη σειρά για να εισέλθουν στο critical section. Η αρχική του τιμή ορίζεται σε 1 για να επιτραπεί η είσοδος 
στην πρώτη διεργασία.
---mutex semaphore:
Το mutex semaphore προστατεύει τη μεταβλητή readers_count, διασφαλίζοντας ότι μόνο μία διεργασία κάθε φορά μπορεί 
να τροποποιήσει ή να ελέγξει τον αριθμό των ενεργών readers. Με αυτόν τον τρόπο αποτρέπονται οι συνθήκες ανταγωνισμού 
και διασφαλίζεται ο σωστός συγχρονισμός.
---write_mutex semaphore:
Το semaphore write_mutex εξασφαλίζει αποκλειστική πρόσβαση για τους writers. Όταν ένας writer θέλει να ενημερώσει 
μια εγγραφή, αποκτά το write_mutex, αποτρέποντας άλλους writers από την ταυτόχρονη τροποποίηση εγγραφών. 
Αυτό εξασφαλίζει ότι μόνο ένας συγγραφέας μπορεί να γράφει κάθε φορά.

Σχετικά με το πώς λειτουργεί το πρόγραμα:

Η main αρχικοποιει τη δομη που εχω για αποθηκευση στατιστικων και την shared memory και στη συνεχεια δημιουργει οσους
readers και οσους writers έχουν ζητηθει απο command line arguments.

Ο reader, περα απο τον χειρισμο των semaphores όπως περιγράφεται παραπανω, ξεκιναει να διαβαζει απο μια
τυχαία εγγραφη και διαβάζει μεχρι 10 εγγραφές (λιγοτερες αν το μεγεθος του αρχειου δεν επαρκει με βαση το σημειο
που έχουμε ξεκινήσει), εκτυπώνοντας παραλληλα κάθε εγγραφή που διαβάζει και καλεί την sleep_random_time στην
οποία δημιουργείται τυχαίος αριθμός ωστε να κανει wait. Την στιγμή που ξεκινάει το δίαβασμα, τοποθετώ το pid του 
στη shared memory (add_active_reader), το αφαιρώ με την ολοκήρωση της διεργασίας του (remove_active_reader)
και τέλος ενημερώνω τα στατιστικά που αφορούν αυτόν.

O writer, περα απο τον χειρισμο των semaphores όπως περιγράφεται παραπανω, επιλέγει τυχαία ένα από τα records 
με βάση το record_count, δημιουργεί τυχαία μια τιμη (θετική ή αρνητική) με απολυτη τιμη μαξ όσο και το τρέχον
υπόλοιπο την εγγραφής, και κάνει το update, εκτυπωνοντας την εγγραφη που αλλαξε και το νεο υπολοιπο. Αφού καλεσει
την sleep_random_time, ενημερώνει και αυτός τα στατιστικά που τον αφορούν. Για την αποθήκευση στη shared memory
των writer που ειναι σε λειτουργια, υπάρχουν οι αντίστοιχες συναρτησεις οπως και στον reader (add_active_writer και
remove_active_writer).

Κάθε φορα που ένας reader ή ένας writer είτε μπαίνει είτε βγαίνει απο το critical section, κάνω καταγραφή της ενέργειας
αυτής καλώντας την log_event η οποια καταγράφει το εκαστοτε γεγονος σε ενα output file το οποιο πέρα απο τα prints που 
γινονται κατευθείαν στο terminal, είναι ο τρόπος να μελετήσω τον συγχρονισμό των διεργασιών.